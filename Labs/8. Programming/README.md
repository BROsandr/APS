# Лабораторная работа 8 "Программирование процессора"

Программа – это последовательность команд, которые требуется выполнить процессору. Программы для процессора представляются в виде машинных инструкций (ноликов и единиц).

## Цель

Написать программу в машинных кодах для процессора с архитектурой `CYBERcobra 3000 Pro 2.0` в соответствии с индивидуальным заданием.

## Ход работы

1. Повторить особенности кодирования инструкций в архитектуре `CYBERcobra 3000 Pro 2.0` ([#теория](#теория))
2. Написать программу для процессора и на модели убедиться в правильности ее выполнения ([#задание по разработке программы](#задание-по-проверке-процессора))
3. Проверить работу процессора на ПЛИС (подключить переключатели и светодиоды ко входам и выходам устройства)

## Теория

Архитектура `CYBERcobra 3000 Pro 2.0` поддерживает 5 типов инструкций, которые кодируются следующим образом (иксами помечены биты, которые не задействованы в данной инструкции):

1. 10 вычислительных инструкций `0 0 11 ALUop RA1 RA2 xxxx xxxx WA`
2. Инструкция загрузки константы `0 0 10 const WA`
3. Инструкция загрузки из внешних устройств `0 0 01 xxx xxxx xxxx xxxx xxxx xxxx WA`
4. Безусловный переход `1 0 00 xxx xxxx xxxx xxxx const xxxx xxxx`
5. 6 инструкций условного перехода `0 1 00 ALUop RA1 RA2 const x xxxx`

![Кодировка инструкции](../../../technical/Labs/Pic/ppd_code_5.png)

При кодировании инструкций используются следующие поля:

- B – однобитный сигнал указывающий на выполнение безусловного перехода
- C – однобитный сигнал указывающий на выполнение условного перехода
- WS – двухбитный сигнал указывающий источник данных для записи в регистровый файл:  
  - 0 – не пишем
  - 1 – с внешних устройств
  - 2 – константа
  - 3 – результат с АЛУ
- ALUop – 5-битный сигнал кода операции АЛУ (в соответствии с таблицей из прошлой лабораторной)
- RA1 и RA2 – 5-битные адреса операндов из регистрового файла
- const – 8-битная константа для условного/безусловного перехода (или 23-битная константа для загрузки в регистровый файл)
- WA – 5-битный адрес регистра, в который будет записан результат

Напишем простую программу для этого процессора, которая в бесконечном цикле увеличивает значение регистра по адресу 5 на 1. Сначала напишем программу на псевдоассемблере (используя предложенную мнемонику):

``` C
  reg[5] ← 0                // загрузить константу 0 в регистр 5
  reg[6] ← 1                // загрузить константу 1 в регистр 6
  reg[5] ← reg[5] + reg[6]  // сложить регистр 5 с регистром 6 и поместить результат в регистр 5
  PC ← PC – 1               // перейти к предыдущей инструкции
```

Теперь в соответствии с кодировкой инструкций переведем программу в машинные коды:

```
  0 0 10   00000000000000000000000  00101
  0 0 10   00000000000000000000001  00110
  0 0 11 00000 00101 00110 00000000 00101
  1 0 00  000000000000000  11111111 00000
```

Полученную программу можно помещать в память программ и выполнять на процессоре.


## Задание по проверке процессора

Для проверки работоспособности разработанного процессора с архитектурой `CYBERcobra 3000 Pro 2.0` необходимо написать программу в машинных кодах в соответствии с одним из индивидуальных заданий (вариант берется у преподавателя) и продемонстрировать ее корректную работу в симуляции и на стенде.

1. Вычислить [циклический сдвиг](https://ru.wikipedia.org/wiki/Битовый_сдвиг#Циклический_сдвиг) вправо `a` >> `IN`
2. Вычислить [циклический сдвиг](https://ru.wikipedia.org/wiki/Битовый_сдвиг#Циклический_сдвиг) влево `a` << `IN`
3. Найти количество единиц в двоичном представлении числа `IN` (обрати внимание `IN` – знаковое число)
4. Сформировать число, состоящее из четных двоичных разрядов числа `IN`. Пример: `IN` = `11_1011_1000`, результат вычислений `OUT` = `1_0100`
5. Найти наибольший двоичный разряд числа `IN`, значение которого равно 1. Если такого нет, вывести 32
6. Поменять в числе `a` разряды `i = IN[4:0]` и `j = IN[9:5]`
7. Если `IN` является степенью двойки, то вывести `1`, в противном случае `0`
8. Найти количество нулей в двоичном представлении числа `IN`
9. Найти количество двоичных разрядов, в которых отличаются числа `IN` и `a`
10. Найти и вывести в `OUT` количество вхождений `a[2:0]` в `IN`
11. Определить, сколько раз встречается `11` в двоичном представлении `IN`, при этом в последовательности `01110` только одно вхождение `11`
12. Инвертировать первые `IN` бит числа `a`
13. Вычислить `a`*`IN` с использованием операций сложений и сдвига ("в столбик")
14. Вывести в `OUT` n-ый член [арифметической прогрессии](https://ru.wikipedia.org/wiki/Арифметическая_прогрессия) aN, где a1 = `a`, d = `IN[15:8]`, n = `IN[7:0]` (d и n неотрицательные)
15. Найти остаток от деления `IN` на `a`
16. Вычислить `a`-`IN` без использования операции вычитания
17. Вывести n-ый член последовательности Фибоначчи Fn. n = `IN`
18. Вывести сумму `IN[3:0]` + `IN[7:4]` + `IN[11:8]` + `IN[15:12]`
19. Если `IN[1:0] == 0`, то выводится `a`,  если `IN[1:0] == 1`, то `b`,  если `IN[1:0] == 2`, то `c`,  если `IN[1:0] == 3`, то `d`
20. Вывести результат целочисленного деления `a`/`IN`
21. *Зажечь все светодиоды на 50% яркости ([спойлер](http://wiki.amperka.ru/конспект-arduino:шим))
22. Вывести подряд все единицы входного числа `IN`. Например, на входе `IN` = `1011011011`, значит на выходе `OUT` = `1111111`
23. Поменять местами четные биты числа `IN` с нечетными битами этого числа (то есть соседние биты поменять местами). Например, `IN` = `1010_0111`, значит `OUT` = `0101_1011`
24. Удалить все вхождения `IN[2:0]` из `a` со сдвигом вправо (заполняя удаленные области). Например, если `a` == `10011010`, `IN[2:0]` == `101`, то `OUT` == `10010`
25. В числе `IN` заменить справа-налево каждое `00` на `11`

Дерзай!
