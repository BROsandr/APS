# Лабораторная работа 8 "Программирование"

## Цель

В рамках данной лабораторной работы вы напишите полноценную программу, которая будет запущена на вашем процессоре. Для этого вам потребуются файлы, лежащие в этой папке.

---

## Ход работы

---

## Теория

В рамках данной лабораторной работы вы напишите полноценную программу, которая будет запущена на вашем процессоре. Для этого вам потребуются файлы, лежащие в этой папке.

> — Но зачем мне эти файлы? Мы ведь уже делали задания по программированию на предыдущих лабораторных работах и нам не были нужны никакие дополнительные файлы.

Дело в том, что ранее вы писали небольшие программки на ассемблере. Однако ассемблер архитектуры RISC-V недружелюбен к программисту, поскольку изначально создавался с прицелом на то, что будут созданы компиляторы и программы будут писаться на языках высокого уровня. Ранее вы писали простенькие программы, которые можно было реализовать на ассемблере,  теперь же вам будет предложено написать полноценную программу на языке Си.

> —  Но разве в процессе компиляции исходного кода на языке Си мы не получаем программу, написанную на языке ассемблера? Получится ведь тот же код, что мы могли написать и сами.

Штука в том, что ассемблерный код который писали ранее вы отличается от ассемблерного кода, генерируемого компилятором. Код, написанный вами обладал скажем так...более тонким микро-контролем хода программы. Когда вы писали программу, вы знали какой у вас размер памяти, где расположены в памяти инструкции, а где данные (ну, точнее вы почти не пользовались памятью данных, а когда пользовались — просто лупили по случайным адресам и все получалось). Вы пользовались всеми регистрами регистрового файла по своему усмотрению, без ограничений. Однако, представьте на секунду, что вы пишете проект на ассемблере вместе с коллегой: вы пишите одни функции, а он другой. Как в таком случае вы будете пользоваться регистрами регистрового файла? Поделите его на пополам и будете пользоваться каждый своей половиной? Но что будет, если к проекту присоединится еще один коллега — придется делить регистровый файл уже на три части? Так от него уже ничего не останется. Для разрешения таких ситуаций было разработано соглашение о вызовах (calling convention).  
Таким образом, генерируя ассемблерный код, компилятор не может так же, как работали вы, используя все ресурсы без каких-либо ограничений — он должен следовать ограничениям, накладываемых соглашением о вызовах, а так же ограничениями того, что он ничего не знает о памяти устройства, в котором будет исполняться программа, поэтому он не может работать с памятью абы как. Работая с памятью, компилятор следует некоторым правилам, благодаря которым после компиляции компоновщик сможет собрать программу под ваше устройство с помощью специального скрипта.

### Соглашение о вызовах

Соглашение о вызовах устанавливает порядок вызова функций: где размещаются аргументы при вызове функций, где находятся указатель на стек и адрес возврата и т.п.  
Кроме того, соглашение делит регистры регистрового файла на две группы: оберегаемые и необерегаемые регистры. При работе с оберегаемыми регистрами, функция должна гарантировать, что перед возвратом в этих регистрах останется тоже самое значение, что было при вызове функции. То есть, если функция собирается записать что-то в оберегаемый регистр, она должна сохранить перед этим его значение на стек, а затем, перед возвратом, вернуть это значение со стека обратно в этот же регистр. С необерегаемыми регистрами функция может работать как ей угодно — не существует никаких гарантий, которые вызванная функция должна исполнить. При этом, если функция вызывает другую функцию, она точно так же не получает никаких гарантий, что вызванная функция оставит значения необерегаемых регистров без изменений, поэтому если там хранятся значения, которые потребуются по окончанию выполнения вызываемой функции, эти значения необходимо сохранить на стек.  

|Register|ABI Name|           Description           | Saver |
|--------|--------|---------------------------------|-------|
|   x0   |  zero  |Hard-wired zero                  |   —   |
|   x1   |  ra    |Return address                   |Caller |
|   x2   |  sp    |Stack pointer                    |Callee |
|   x3   |  gp    |Global pointer                   |   —   |
|   x4   |  tp    |Thread pointer                   |   —   |
|  x5–7  |  t0–2  |Temporaries                      |Caller |
|   x8   |  s0/fp |Saved register/frame pointer     |Callee |
|   x9   |  s1    |Saved register                   |Callee |
| x10–11 |  a0–1  |Function arguments/return values |Caller |
| x12–17 |  a2–7  |Function arguments               |Caller |
| x18–27 |  s2–11 |Saved registers                  |Callee |
| x28–31 |  t3–6  |Temporaries                      |Caller |

В данной таблице приведено разделение регистров на оберегаемые (в правом столбце записано `Callee`, т.е. за их сохранение отвечает вызванная функция) и необерегаемые (`Caller` — за сохранение отвечает вызывающая функция). Кроме того, есть три регистра, для которых правый столбец не имеет значения: нулевой регистр (поскольку его невозможно изменить). И указатели на стек и глобальную область памяти. По соглашению о вызовах, эти регистры нельзя использовать для вычислений функций, они изменяются только по заранее оговоренным ситуациям (например, перед тем как сохранить данные на стек, сперва значение указателя на стек).

### Скрипт для компоновки (linker_script.ld)

Скрипт для компоновки описывает то, как в вашей памяти будут храниться данные. Вы уже могли слышать о том, что исполняемый файл содержит секции `.text` и `.data` — инструкций и данных соответственно. Линковщик ничего не знает о том, какая у вас структура памяти: принстонская у вас архитектура или гарвардская, по каким адресам у вас должны храниться инструкции, а по каким данные. У вас может быть несколько типов памятей, под особые секции — и обо всем этом линковщику можно сообщить в скрипте для компоновки.  
В самом простом виде скрипт компоновки состоит из одного раздела: раздела секций, в котором вы и описываете какие части программы куда и в каком порядке необходимо разместить.  
Для удобства этого описания существует вспомогательная переменная: счетчик адресов. В начале скрипта этот счетчик равен нулю. Размещая очередную секцию, этот счетчик увеличивается на размер этой секции. Допустим, у нас есть два файла `fourier.o` и `main.o`, в каждом из которых есть секции `.text` и `.data`. Мы хотим разместить их в памяти следующим образом: сперва разместить секции `.text` обоих файлов, а затем секции `.data`.  
В итоге по нулевом адресу будет размещена секция `.text` файла `fourier.o`. Она будет размещена именно там, поскольку счетчик адресов в начале скрипта равен нулю, а очередная секция размещается по адресу, куда указывает счетчик адресов. После этого, счетчик адресов будет увеличен на размер этой секции и секция `.text` файла `main.o` будет размещена сразу же за секцией `.text` файла `fourier.o`. После этого счетчик адресов будет увеличен на размер этой секции. То же самое произойдет и при размещении оставшихся секций.  
Кроме того, вы в любой момент можете изменить значение счетчика адресов. Например, у вас две раздельные памяти: память инструкций объемом 512 байт и память данных объемом 1024 байта. Эти памяти находятся в одном адресном пространстве. Диапазон адресов памяти инструкций: [0:511], диапазон памяти данных: [512:1535]. При этом общий объем секций `.text` составляет 416 байт. В этом случае, вы можете сперва разместить секции `.text` так же, как было описано в предыдущем примере, а затем, выставив значение на счетчике адресов равное `512`, описываете размещение секций данных. В этом случае, между секциями будет разрыв в 96 байт.  
Помимо прочего, в скрипте компоновщика необходимо прописать где будет находиться стек, и куда будет указывать указатель на глобальную область памяти.
Все это с подробными комментариями описано в файле `linker_script.ld`.

```ld
OUTPUT_FORMAT("elf32-littleriscv")
ENTRY(_start)

SECTIONS
{
  PROVIDE( _start = 0x00000000 );
  PROVIDE( _memory_size = 2048); /* 2048 байт */
  PROVIDE( _interrupt_stack_size = 160); /* данный размер позволяет выполнить
                                            обработку двух прерываний */

  .text : {*(.boot) *(.text*)}
  /*
    В скриптах линковщика есть внутренняя переменная, записываемая как '.'
    Эта переменная называется счетчиком адресов. Она хранит текущий адрес в
    памяти.
    В начале файла она инициализируется нулем. Добавляя новые секции, эта
    переменная будет увеличиваться на размер каждой новой секции.
    Если при размещении секций не указывается никакой адрес, они будут размещены
    по текущему значению счетчика адресов.
    Этой переменной можно присваивать значения, после этого, она будет
    увеличиваться с этого значения.
    Подробнее:
      https://home.cs.colorado.edu/~main/cs1300/doc/gnu/ld_3.html#IDX338
  */
  . = ALIGN(4);
  .data : {*(.data*)}
  /*
    Значение, присвоенное глобальному указателю (GP) выходит за границы RAM,
    однако (для архитектуры RISC-V) общепринято присваивать GP значение равное
    началу секции данных, смещенное на 2048 байт вперед.
    Благодаря относительной адресации со смещением в 12 бит, можно адресоваться
    на начало секции данных, а так же по всему адресному пространству вплоть до
    4096 байт от начала секции данных, что сокращает объем требуемых для
    адресации инструкций (практически не используются операции LUI, поскольку GP
    уже хранит базовый адрес и нужно только смещение).
    Подробнее:
      https://groups.google.com/a/groups.riscv.org/g/sw-dev/c/60IdaZj27dY/m/s1eJMlrUAQAJ
  */
  _gbl_ptr = . + 0x800 ;
  . = ALIGN(4);
  /*
    BSS (block started by symbol, неофициально его расшифровывают как
    better save space) — это сегмент, в котором размещаются неинициализированные
    статические переменные. В стандарте Си сказано, что такие переменные
    инициализируются нулем (или NULL для указателей). Когда вы создаете
    статический массив — он должен быть размещен в исполняемом файле.
    Без bss-секции, этот массив должен был бы занимать такой же объем
    исполняемого файла, какого объема он сам. Массив на 1000 байт занял бы
    1000 байт в секции .data.
    Благодаря секции bss, начальные значения массива не задаются, вместо этого
    здесь только записываются названия переменных и их адреса.
    Однако на этапе загрузки исполняемого файла теперь необходимо принудительно
    занулить участок памяти, занимаемый bss-секцией, поскольку статические
    переменные должны быть проинициализированы нулем.
    Таким образом, bss-секция значительным образом сокращает объем исполняемого
    файла (в случае использования неинициализированных статических массивов)
    ценой увеличения времени загрузки этого файла.
    Для того, чтобы занулить bss-секцию, в скрипте заводятся две переменные,
    указывающие на начало и конец bss-секции посредством счетчика адресов.
    Подробнее:
      https://en.wikipedia.org/wiki/.bss
  */
  _bss_start = .;
  .bss : {*(.bss*)}
  _bss_end = .;


  /*=================================
      Секция аллоцированных данных завершена, остаток свободной памяти отводится
      под программный стек, стек прерываний и (возможно) кучу. В соглашении о
      вызовах архитектуры RISC-V сказано, что стек растет снизу вверх, поэтому
      наша цель разместить его в самых последних адресах памяти.
      Поскольку стеков у нас два, в самом низу мы разместим стек прерываний, а
      над ним программный стек. При этом надо обеспечить защиту программного
      стека от наложения на него стека прерываний.
      Однако перед этим, мы должны убедиться, что под программный стек останется
      хотя бы 256 байт (ничем не обоснованное число, взятое с потолка).
      Поскольку указатель стека (SP) должен быть выровнен до 16 байт, мы
      обеспечиваем себе максимум 16 вложенных вызовов.
      Подробнее:
        https://riscv.org/wp-content/uploads/2015/01/riscv-calling.pdf
    =================================
  */

  /* Мы хотим гарантировать, что под стек останется как минимум 256 байт */
  ASSERT(. < (_memory_size - _interrupt_stack_size - 256),
            "Program size is too big")

  /*  Перемещаем счетчик адресов над стеком прерываний (чтобы после мы могли
      использовать его в вызове ALIGN) */
  . = _memory_size - _interrupt_stack_size;

  /*
      Размещаем указатель программного стека так близко к границе стека
      прерываний, насколько можно с учетом требования о выравнивании адреса
      стека до 16 байт.
  */
  _stack_ptr = ALIGN(16) <= _memory_size - _interrupt_stack_size?
                ALIGN(16) : ALIGN(16) - 16;
  ASSERT(_stack_ptr <= _memory_size - _interrupt_stack_size, "SP exceed memory size")

  /*  Перемещаем счетчик адресов в конец памяти (чтобы после мы могли
      использовать его в вызове ALIGN) */
  . = _memory_size;

  /*
      Обычно память имеет размер, кратный 16, но на случай, если это не так, мы
      делаем проверку, после которой мы либо остаемся в самом конце памяти (если
      конец кратен 16), либо поднимаемся на 16 байт вверх от края памяти,
      округленного до 16 в сторону большего значения
  */
  _interrupt_stack_ptr = ALIGN(16) <= _memory_size ? ALIGN(16) : ALIGN(16) - 16;
  ASSERT(_interrupt_stack_ptr <= _memory_size, "ISP exceed memory size")
}

```

### Файл первичных команд при загрузке (startup.S)

В стартап-файле хранятся инструкции, которые обязательно необходимо выполнить перед началом исполнения любой программы. Это инициализация регистров указателей на стек и глобальную область данных, регистра, хранящего адрес вектора прерываний и т.п.  
По завершению инициализации, стартап-файл выполняет процедуру передаче управления точке входа в запускаемую программу.  

```asm
  .section    .boot

 .global _start
_start:
  la    gp, _gbl_ptr     # Инициализация глобального указателя
  la    sp, _stack_ptr   # Инициализация указателя на стек

# Инициализация (зануление) сегмента bss
  la    t0, _bss_start
  la    t1, _bss_end
_bss_init_loop:
  beq   t0, t1, _irq_config
  sw    zero, 0(t0)
  addi  t0, t0, 4
  j     _bss_init_loop

# Настройка вектора (mtvec) и маски (mie) прерываний
# (У групп, не реализовывавших контроллер прерываний инструкции csrw будут
#  интерпретированы как illegal instruction — это нормально для данного примера)
_irq_config:
  la    t0, __int_handler
  li    t1, -1 # -1 (все биты равны 1) означает, что разрешены все прерывания
  csrw  mtvec, t0
  csrw  mie, t1

# Вызов функции main
_main_call:
  li    a0, 0 # Передача аргументов argc и argv в main. Формально, argc должен
  li    a1, 0 # быть больше нуля, а argv должен указывать на массив строк,
              # нулевой элемент которого является именем исполняемого файла,
              # Но для простоты реалзации оба аргумента всего лишь обнулены.
              # Это сделано для детерменированного поведения программы в случае,
              # если будет пытаться использовать эти аргументы.
  call  main
# Зацикливание после выхода из функции main
_endless_loop:
  j     _endless_loop


# ==============================================================================
#
#          Конец файла для групп, не выполнявших лабу с преыванииями
#
# ==============================================================================




# Низкоуровневый обработчик прерывания (будет использоваться только у групп,
# с лабой по прерываниям), отвечает за:
#   * Сохранение и восстановление контекста;
#   * Вызов высокоуровневого обработчика с передачей id источника прерывания в
#     качестве аргумента.
# В основе кода лежит обработчик из репозитория urv-core:
# https://github.com/twlostow/urv-core/blob/master/sw/common/irq.S
# Из реализации убраны сохранения нереализованных CS-регистров. Кроме того,
# судя по документу приведенному ниже, обычное ABI подразумевает такое же
# сохранение контекста, что и при программном вызове (EABI подразумевает еще
# меньшее сохранение контекста), поэтому нет нужды сохранять весь регистровый
# файл.
# Документ:
#  https://github.com/riscv-non-isa/riscv-eabi-spec/blob/master/EABI.adoc
__int_handler:
  # Данная операция меняет местами регистры sp и mscratch.
  # В итоге указатель на стек прерываний оказывается в регистре sp, а вершина
  # программного стека оказывается в регистре mscratch.
  csrrw sp,mscratch,sp

  # Далее мы поднимаемся по стеку прерываний и сохраняем все регистры.
  addi  sp,sp,-80  # Указатель на стек должен быть выровнен до 16 байт, поэтому
                    # поднимаемся вверх не на 76, а на 80.
  sw    ra,4(sp)
  # Мы хотим убедиться, что очередное прерывание не наложит стек преываний на
  # программный стек, поэтому записываем в освободившийся регистр низ
  # программного стека, и проверяем что приподнятый указатель на верхушку
  # стека прерываний не залез в программный стек.
  # В случае, если это произошло (произошло переполнение стека прерываний),
  # мы хотим остановить работу процессора, чтобы не потерять данные, которые
  # могут помочь нам в отладке этой ситуации.
  la    ra, _stack_ptr
  blt   sp, ra, _endless_loop

  sw    t0,12(sp) # Мы перепрыгнули через смещение 8, поскольку там должен
                  # лежать регистр sp, который ранее сохранили в mscratch.
                  # Мы запишем его на стек чуть позже.
  sw    t1,16(sp)
  sw    t2,20(sp)
  sw    a0,24(sp)
  sw    a1,28(sp)
  sw    a2,32(sp)
  sw    a3,36(sp)
  sw    a4,40(sp)
  sw    a5,44(sp)
  sw    a6,48(sp)
  sw    a7,52(sp)
  sw    t3,56(sp)
  sw    t4,60(sp)
  sw    t5,64(sp)
  sw    t6,68(sp)

  # Кроме того, мы сохраняем состояние регистров прерываний на случай, если
  # произойдет еще одно прерывание.
  csrr  t0,mscratch
  csrr  t1,mepc
  csrr  a0,mcause
  sw    t0,8(sp)
  sw    t1,72(sp)
  sw    a0,76(sp)

  # Вызов высокоуровневого обработчика прерываний
  call  int_handler

  # Восстановление контекста. В первую очередь мы хотим воссановить CS-регистры,
  # на случай, если происходило вложенное прерывание. Для этого, мы должны
  # вернуть исходное значение указателя стека прерываний. Однако его нынешнее
  # значение нам еще необходимо для восстановелния контекста, поэтому мы
  # сохраним его в регистр a0, и будем восстанавливаться из него.
  mv    a0,sp

  lw    t1,132(a0)
  addi  sp,sp,144
  csrw  mscratch,sp
  csrw  mepc,t1
  lw    ra,4(a0)
  lw    sp,8(a0)
  lw    t0,12(a0)
  lw    t1,16(a0)
  lw    t2,20(a0)
  lw    a1,28(a0)   # Мы пропустили a0, потому что сейчас он используется в
                    # качестве указателя на верхушку стека и не может быть
                    # восстановлен.
  lw    a2,32(a0)
  lw    a3,36(a0)
  lw    a4,40(a0)
  lw    a5,44(a0)
  lw    a6,48(a0)
  lw    a7,52(a0)
  lw    t3,56(a0)
  lw    t4,60(a0)
  lw    t5,64(a0)
  lw    t6,68(a0)
  lw    a0,40(a0)

  # Выход из обработчика прерывания
  mret

```

## Практика

Для того, чтобы запустить симуляцию исполнения программы на вашем процессоре, сперва эту программу необходимо скомпилировать и преобразовать в текстовый файл, которым САПР сможет проинициализировать память процессора. Для компиляции программы, вам потребуется особый компилятор, называемый "кросскомпилятор". Он позволяет комплиировать исходный код под архитектуру компьютера, отличную от компьютера, на котором ведется компиляция. В нашем случае, вы будете собирать код под архитектуру RISC-V на компьютере с архитектурой x86_64.  
Компилятор, который подойдет для данной задачи (для запуска в операционной системе Windows) вы можете скачать [отсюда](https://sysprogs.com/getfile/1107/risc-v-gcc10.1.0.exe).  
Вам потребуется скомпилировать файлы с исходным кодом в объектные. Это можно сделать следующей командой:  

```
<исполняемый файл компилятора> -с <флаги компиляции> <входной файл с исходным кодом> -o <выходной объектный файл>
```

Вам потребуются следующие флаги компиляции:

* `-march=rv32i` — указание разрядности и набора расширений в архитектуре, под которую идет компиляция
* `-mabi=ilp32`  — указание двоичного интерфейса приложений

С учетом названия исполнямого названия скачанного вами компилятора (при условии, что вы установили его по предложенному установщиком пути), командой для компиляции файла `startup.S` может быть:


```
/c/sysgcc/risc-v/bin/riscv64-unknown-elf-gcc -c -march=rv32i -mabi=ilp32 startup.S -o startup.o
```

Далее необходимо выполнить компоновку объектных файлов. Это можно выполнить командной следующего формата:

```
<исполняемый файл компилятора> <флаги компоновки> <входные объектные файлы> -o <выходной объектный файл>
```

Исполняемый файл компилятора тот же самый, флаги компоновки будут следующие:
* -Wl,--gc-sections — указать компоновщику удалять неиспользуемые секции (сокращает объем итогового файла)
* -nostartfiles     — указать компоновщику не использовать стартап-файлы стандартных библиотек (сокращает объем файла)
* -T $(LINK_SCRIPT) — передать компоновщику скрипт компоновки

Пример команды компановки:

```
/c/sysgcc/risc-v/bin/riscv64-unknown-elf-gcc -Wl,--gc-sections -nostartfiles -T linker_script.ld startup.o main.o -o result.elf
```

В результате компоновки вы получите исполняемый файл формата `elf` (Executable and Linkable Format). Это двоичный файл, однако это не просто набор двоичных инструкций и данных, которые будут загружены в память процессора. Данный файл содержит заголовки и специальную информацию, которая поможет загрузчику разместить этот файл в памяти компьютера. Поскольку роль загрузчика будете выполнять вы и САПР, на котором будет вестись моделирование, эти данные вам не понадобятся, поэтому вам потребуется экспортировать из данного файла только двоичные инструкции и данные, отбросив всю остальную информацию. Полученный файл уже можно будет использовать в функции `$readmemh`.  
Для экспорта используйте команду:

```
/c/sysgcc/risc-v/bin/riscv64-unknown-elf-objcopy -O verilog result.elf init.mem
```

ключ `-O verilog` говорит о том, что файл надо сохранить в формате, который сможет воспринять команда `$readmemh`.  
Если память инструкций и данных у вас разделены, можно экспортировать отдельные секции в разные файлы:

```
/c/sysgcc/risc-v/bin/riscv64-unknown-elf-objcopy -O verilog -j .text result.elf init_instr.mem
/c/sysgcc/risc-v/bin/riscv64-unknown-elf-objcopy -O verilog -j .data -j .bss result.elf init_data.mem
```

---

## Задание

---

### Порядок выполнения задания

1. Скомпилировать программу и стартап-файл в объектные файлы
2. Скомпоновать объектные файлы исполняемый файл.
3. Экспортировать секции из объектного файла в текстовый файл под архитектуру вашего процессора (принстонскую/гарвадскую)
4. Добавить файлы в проект Vivado
5. Запустить моделирование исполнения программы вашим процессором. Для этого необходимо написать тестбенч, формирующий тактовый синхроимпульс и сигнал сброса (если ваша группа реализовывала лабу по прерываниям, то тестбенч должен так же формировать сигнал прерывания, причем желательно проверить глубину прерываний,  во время обработки первого прерывания чтобы пришел сигнал о втором, и т.д.)
6. Убедиться в корректном исполнении программы (и обработчика прерывания для групп с прерываниями).

---
